{"name":"Pliable","tagline":"Schemaless data integration with Rails and Postgres","body":"pliable\r\n============\r\n| Project                 |  Gem Release      |\r\n|------------------------ | ----------------- |\r\n| Gem name                |  pliable      |\r\n| License                 |  [MIT](LICENSE.txt)   |\r\n| Version                 |  [![Gem Version](https://badge.fury.io/rb/pliable.png)](http://badge.fury.io/rb/pliable) |\r\n| Continuous Integration  |  [![Build Status](https://travis-ci.org/mfpiccolo/pliable.png?branch=master)](https://travis-ci.org/mfpiccolo/pliable)\r\n| Test Coverage           |  [![Coverage Status](https://coveralls.io/repos/mfpiccolo/pliable/badge.png?branch=master)](https://coveralls.io/r/mfpiccolo/pliable?branch=coveralls)\r\n| Grade                   |  [![Code Climate](https://codeclimate.com/github/mfpiccolo/pliable.png)](https://codeclimate.com/github/mfpiccolo/pliable)\r\n| Homepage                |  [http://mfpiccolo.github.io/pliable][homepage] |\r\n| Documentation           |  [http://rdoc.info/github/mfpiccolo/pliable/frames][documentation] |\r\n| Issues                  |  [https://github.com/mfpiccolo/pliable/issues][issues] |\r\n\r\n## Description\r\n\r\nPliable makes integrating a Rails project with Schemaless data not so painful.\r\n\r\nRolling your own integration with an external service where the schema can change from moment to moment can be tough.  Pliable makes it a bit easier by giving you a familiar place to store this data (models backed by postgres) and familiar ways of interacting with it (Active Record objects, complete with associations).\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem \"pliable\"\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install pliable\r\n\r\n## Features\r\n\r\nPliable allows you to save individual records from external schemaless databases into your postgres\r\nbacked rails apps.  We store all of the data in a plies table.  The Ply model contains logic that allows\r\nyou to inherit from Ply and then act as if these iherited models are normal Active Record models.\r\n\r\nHere is the Ply model your generator created:\r\n\r\n```ruby\r\nclass Ply < Pliable::Ply\r\n  # Define methods here that you want all you Ply backed models to have.\r\nend\r\n```\r\n\r\nNow you can create a model that is backed by Ply.\r\n\r\n```ruby\r\nclass Foo < Ply\r\n  # This is redundant if it is the same name ass the class but required for now.\r\n  ply_name \"Foo\"\r\n  # Define methods that you only want Foo to have.\r\nend\r\n```\r\n\r\nNow lets make another Ply Backed Model.\r\n\r\n```ruby\r\nclass Bar < Ply\r\n  ply_name \"Bar\"\r\nend\r\n```\r\n\r\nNow you should be able to treat these like any other Active Record object with the added bonus of a\r\nfew features.  You can assign any json data to the data attribute.\r\n\r\n```ruby\r\nfoo = Foo.create(data: {\"some\" => \"json\", \"other\" => \"data\"})\r\n```\r\nThe nice part is now these json keys are methods.\r\n```ruby\r\nfoo.some => \"json\"\r\n```\r\n\r\nAnother nicety is associations.  You can associate a Ply inhereted class to another using parent\r\nand child relationships and the PlyRelations model\r\n```ruby\r\nfoo = Foo.create\r\nbar = Bar.create\r\nPlyRealation.create(parent_id: foo.id, parent_type: foo.class.name, child_id: bar, child_type: bar.class.name)\r\n\r\nfoo.bars => <#<ActiveRecord::AssociationRelation [#<Pliable::Ply id: 2 otype: \"Bar\" ...>\r\n```\r\n\r\n## Configuration\r\n\r\nTo use the generator run:\r\n\r\n    $ rails g pliable:model\r\n\r\nThis will set up pliable.rb initializer, create the migration and run it and add a Ply model and specs.\r\n\r\nIn the initializer, specify any aditional logic you need to prepare the ply_name for pluralization.\r\n\r\n```ruby\r\nPliable.configure do |config|\r\n  # Add logic to this bloc to change the names given by external services so we can pluralize.\r\n  # For instance if you ply names need to gsub __c of the end do:\r\n  config.added_scrubber {|name| name.gsub('__c', '') }\r\nend\r\n```\r\n\r\n## Examples\r\n\r\nAn example of a salesforce integration:\r\n\r\nHere is your Ply model:\r\n\r\n```ruby\r\n# Notice it inherits from Pliable::Ply\r\nclass Ply < Pliable::Ply\r\n\r\n  # Define methods here that you want all of your models to have\r\n  def anything_you_like\r\n    puts \"I can play disco all night\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nThis is an example salesforce Invoice model:\r\n\r\n```ruby\r\n# Notice it inherits from your apps Ply\r\nclass Invoice < Ply\r\n\r\n  # If you dont put this you will get all Ply records.\r\n  # This is the name that you have put into the otype attribute.\r\n  # In this example I just used the exact salesforce api name\r\n  ply_name \"Invoice__c\"\r\n\r\n  # Add Invoice specific methods here\r\n  def what_dosnt_gather_moss?\r\n    \"A rolling stone!\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nHere is an example associated salesforce model:\r\n\r\n```ruby\r\nclass LineItem < Ply\r\n\r\n  ply_name \"Line_Item__c\"\r\n\r\n  # You guessed it.  LineItem specific methods here.\r\n  def best_pliable_quote\r\n    \"Facts are stubborn, but statistics are more pliable. - Mark Twain\"\r\n  end\r\n\r\nend\r\n```\r\n\r\nHere is your PlyRelation model:\r\n\r\n```ruby\r\n# This will probably not be needed in the future and will live in the gem\r\nclass PlyRelation < ActiveRecord::Base\r\n  belongs_to :parent, class_name: 'Ply'\r\n  belongs_to :child, class_name: 'Ply'\r\nend\r\n```\r\n\r\nA service object for pulling salesforce data into your app:\r\n\r\n```ruby\r\nclass SalesforceSynch\r\n\r\n  attr_reader :user, :client\r\n\r\n  def initialize(user)\r\n    @user = user\r\n  end\r\n\r\n  def call\r\n    set_clients  # Connect to your Salesforce data (i.e. databsedotcom or restforce)\r\n    create_plys_from_salesforce_records # Create records in your PG database using Ply model\r\n    create_ply_relations # Dynamically create associations based on the data recieved\r\n  end\r\n\r\n  def self.call\r\n    new.call\r\n  end\r\n\r\n  def set_clients\r\n    #Fake service object that sets up a client to connect to databasedotcom\r\n    @client = ConnectToDatabasedotcom.call(user.salesforce_credentials)\r\n  end\r\n\r\n  def create_plys_from_salesforce_records\r\n    data = []\r\n\r\n    # sf_api model names as strings in array\r\n    records = []\r\n\r\n    # User has_many :plies in this example (i.e. user.plies)\r\n    client.get_the_records_you_want.each do |record|\r\n      object = user.plies.find_or_create_by(oid: record.Id)\r\n      object.update_attributes(\r\n        # The data attribute is a json column.  This is where you store all shcemaless data.\r\n        data: record.attributes,\r\n        # Whatever the service calls the object (i.e. Invoice__c for salesforce)\r\n        otype: record.salesforce_api_name,\r\n        # Use last_checked and last_modified to know when you need to update a record\r\n        last_checked: Time.zone.now\r\n      )\r\n    end\r\n  end\r\n\r\n  # Dynamically deduce if there is a relationship with any of the plys that have been imported.\r\n  # In the case of saleforce the id of related object is stored by using the name of that\r\n  # object as a key. (ie \"Invoice__c\" => \"long_uiniq_id\").  In this app users choose a few models\r\n  # that they want to bring over but you could easily just get everything.\r\n    user.plies.each do |ply|\r\n      related_model_names = ply.instance_variables.map {|e| e.to_s.gsub(\"@\", \"\") } & user.model_names\r\n      related_model_names.each do |name|\r\n        child = Ply.find_by_oid(ply.send(name.to_sym))\r\n        unless PlyRelation.where(parent_id: record.id, child_id: child.id).present?\r\n          ply.children.new(\r\n            parent_id: ply.id,\r\n            parent_type: ply.otype,\r\n            child_id: ply.id,\r\n            child_type: ply.otype\r\n            ).save # #create does not work yet.  Sorry\r\n        end\r\n      end\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNow with this setup you can run something like this\r\n\r\n```ruby\r\nSalesforceSynch.call(@user)  # Awesome.  You just imported all your salesforce data.\r\n\r\ninvoice = Invoice.first => #<Invoice id: 1, user_id: 1, oid: \"randomnumber\", otype: \"Invoice__c\",\r\n# data: {\"Id\"=>\"a00i000000BbWLvAAN\", \"OwnerId\"=>\"005i0000002NdyWAAS\", \"Owner\"=>nil...}...>\r\n\r\ninvoice.line_items => #<ActiveRecord::AssociationRelation [#<Pliable::Ply id: 2 ...>\r\n\r\ninvoice.line_items.first.invoices.find(invoice.id) === invoice => true\r\n\r\ninvoice.SalesForceCustomAttribute__c => Whatever it is in salesforce.\r\n\r\nInvoice.all => #<ActiveRecord::Relation [#<Invoice id: 136, user_id: 1...>\r\n\r\nLineItem.first => #<LineItem id: 145, user_id: 1...>\r\n\r\nInvoice.find_by_oid(\"random_oid_number\") => #<Invoice id: 132, user_id: 1, oid: \"rand...\">\r\n\r\n# All the normal active-recordy goodness\r\n```\r\n\r\n## Requirements\r\n\r\n## Donating\r\nSupport this project and [others by mfpiccolo][gittip-mfpiccolo] via [gittip][gittip-mfpiccolo].\r\n\r\n[gittip-mfpiccolo]: https://www.gittip.com/mfpiccolo/\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2013 Mike Piccolo\r\n\r\nSee [LICENSE.txt](LICENSE.txt) for details.\r\n\r\n## Contributing\r\n\r\n1. Fork it ( http://github.com/<my-github-username>/pliable/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/e1a155a07163d56ca0c4f246c7aa8766 \"githalytics.com\")](http://githalytics.com/mfpiccolo/pliable)\r\n\r\n[license]: https://github.com/mfpiccolo/pliable/MIT-LICENSE\r\n[homepage]: http://mfpiccolo.github.io/pliable\r\n[documentation]: http://rdoc.info/github/mfpiccolo/pliable/frames\r\n[issues]: https://github.com/mfpiccolo/pliable/issues\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}